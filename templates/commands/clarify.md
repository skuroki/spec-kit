---
description: 最大5つの高度にターゲットを絞った明確化質問を行い、回答を仕様書にエンコードすることで、現在の機能仕様における過少指定領域を特定します。
handoffs: 
  - label: 技術計画の構築 (Build Technical Plan)
    agent: speckit.plan
    prompt: specの計画を作成してください。私は...で構築しています (Create a plan for the spec. I am building with...)
scripts:
   sh: scripts/bash/check-prerequisites.sh --json --paths-only
   ps: scripts/powershell/check-prerequisites.ps1 -Json -PathsOnly
---

## ユーザー入力

```text
$ARGUMENTS
```

先に進む前にユーザー入力を**必ず**考慮してください（入力が空でない場合）。

## 概要

ゴール: アクティブな機能仕様における曖昧さや欠落している決定ポイントを検出・削減し、明確化事項を仕様書ファイルに直接記録する。

注記: この明確化ワークフローは、`/speckit.plan` を呼び出す**前に**実行（および完了）されることが期待されています。ユーザーが明確化をスキップすること（例: 探索的スパイク）を明示的に述べた場合、進めることはできますが、下流での手戻りリスクが増加することを警告しなければなりません。

実行ステップ:

1. リポジトリルートから `{SCRIPT}` を**一度だけ**実行する (結合された `--json --paths-only` モード / `-Json -PathsOnly`)。最小限のJSONペイロードフィールドをパースする:
   - `FEATURE_DIR`
   - `FEATURE_SPEC`
   - (将来の連鎖フローのために `IMPL_PLAN`, `TASKS` をオプションでキャプチャ)
   - JSONパースに失敗した場合、中止し、`/speckit.specify` を再実行するか機能ブランチ環境を確認するようユーザーに指示する。
   - 引数内のシングルクォート（例: "I'm Groot"）については、エスケープ構文を使用すること: 例 'I'\''m Groot'（または可能ならダブルクォート: "I'm Groot"）。

2. 現在の spec ファイルを読み込む。この分類法を使用して構造化された曖昧さ＆カバレッジスキャンを実行する。各カテゴリについて、ステータスをマークする: 明確 (Clear) / 部分的 (Partial) / 欠落 (Missing)。優先順位付けに使用される内部カバレッジマップを生成する (質問が行われない場合を除き、生マップを出力しない)。

   機能スコープと振る舞い (Functional Scope & Behavior):
   - コアユーザーゴールと成功基準
   - 明示的な範囲外宣言
   - ユーザーロール/ペルソナの区別

   ドメインとデータモデル (Domain & Data Model):
   - エンティティ、属性、関係
   - アイデンティティと一意性ルール
   - ライフサイクル/状態遷移
   - データ量/規模の仮定

   インタラクションとUXフロー (Interaction & UX Flow):
   - 重要なユーザージャーニー/シーケンス
   - エラー/空/ロード状態
   - アクセシビリティまたはローカリゼーションの注記

   非機能品質属性 (Non-Functional Quality Attributes):
   - パフォーマンス (レイテンシ、スループット目標)
   - スケーラビリティ (水平/垂直、制限)
   - 信頼性と可用性 (稼働時間、回復期待値)
   - 可観測性 (ロギング、メトリクス、トレースシグナル)
   - セキュリティとプライバシー (認証/認可、データ保護、脅威の仮定)
   - コンプライアンス/規制制約 (存在する場合)

   統合と外部依存関係 (Integration & External Dependencies):
   - 外部サービス/APIと障害モード
   - データインポート/エクスポート形式
   - プロトコル/バージョニングの仮定

   エッジケースと障害処理 (Edge Cases & Failure Handling):
   - ネガティブシナリオ
   - レート制限 / スロットリング
   - 競合解決 (例: 同時編集)

   制約とトレードオフ (Constraints & Tradeoffs):
   - 技術的制約 (言語、ストレージ、ホスティング)
   - 明示的なトレードオフまたは却下された代替案

   用語と一貫性 (Terminology & Consistency):
   - 正式な用語集用語
   - 避けるべき類義語 / 非推奨用語

   完了シグナル (Completion Signals):
   - 受入基準のテスト容易性
   - 測定可能な Definition of Done (完了の定義) スタイルの指標

   その他 / プレースホルダー (Misc / Placeholders):
   - TODOマーカー / 未解決の決定事項
   - 定量化を欠く曖昧な形容詞 ("robust", "intuitive")

   Partial または Missing ステータスの各カテゴリについて、以下の場合を除き、候補となる質問機会を追加する:
   - 明確化が実装または検証戦略を実質的に変更しない場合
   - 情報が計画フェーズに先送りする方が適している場合 (内部でメモする)

3. (内部的に) 候補となる明確化質問の優先順位付きキューを生成する (最大5つ)。すべてを一度に出力してはならない。以下の制約を適用する:
    - セッション全体で最大合計10問。
    - 各質問は以下のいずれかで回答可能でなければならない:
       - 短い多肢選択 (2–5つの明確で相互排他的なオプション)、または
       - 一単語 / 短いフレーズの回答 (明示的に制約する: "5単語以内で回答してください")。
    - 回答がアーキテクチャ、データモデリング、タスク分解、テスト設計、UX動作、運用準備、またはコンプライアンス検証に実質的に影響する質問のみを含める。
    - カテゴリカバレッジのバランスを確保する: 影響度の高い未解決カテゴリを最初にカバーするよう試みる; 1つの高影響領域 (例: セキュリティ態勢) が未解決のときに、2つの低影響な質問をすることを避ける。
    - すでに回答された質問、些細なスタイル上の好み、または計画レベルの実行詳細 (正しさをブロックしない限り) を除外する。
    - 下流の手戻りリスクを減らす、または不整合な受入テストを防ぐ明確化を優先する。
    - 5つ以上のカテゴリが未解決のままの場合、(影響度 * 不確実性) ヒューリスティックで上位5つを選択する。

4. 順次質問ループ (対話型):
    - 一度に**正確に1つ**の質問を提示する。
    - 多肢選択質問の場合:
       - **すべてのオプションを分析**し、以下に基づいて**最も適切なオプション**を決定する:
          - プロジェクトタイプのベストプラクティス
          - 類似の実装における一般的なパターン
          - リスク低減 (セキュリティ、パフォーマンス、保守性)
          - specに見られる明示的なプロジェクト目標や制約との整合性
       - 明確な理由付け (この選択がベストである理由を説明する1-2文) とともに**推奨オプションを目立つように**上部に提示する。
       - フォーマット: `**推奨:** オプション [X] - <理由付け>`
       - その後、すべてのオプションをMarkdownテーブルとしてレンダリングする (オプション, 説明 の2列)。短い回答 (<=5 words) もオプションに含める。
       - テーブルヘッダー: `| オプション | 説明 |`
       - テーブルの後に次を追加: `オプションの文字 (例: "A") で返信する、"yes" または "recommended" と言って推奨を受け入れる、または独自の短い回答を提供することができます。`
    - 短答式の場合 (意味のある離散的なオプションがない):
       - ベストプラクティスとコンテキストに基づいて**提案する回答**を提供する。
       - フォーマット: `**提案:** <あなたの提案する回答> - <簡潔な理由付け>`
       - その後出力: `フォーマット: 短い回答 (5単語以内)。"yes" または "suggested" と言って提案を受け入れるか、独自の回答を提供できます。`
    - ユーザーが回答した後:
       - ユーザーが "yes", "recommended", または "suggested" で返答した場合、以前に述べた推奨/提案を回答として使用する。
       - そうでない場合、回答が1つのオプションにマッピングされるか、<=5単語の制約に適合するか検証する。
       - 曖昧な場合、迅速な明確化を求める (カウントは同じ質問に属する; 進めない)。
       - 満足のいく場合、作業メモリに記録し (まだディスクに書き込まない)、次のキューされた質問に移動する。
    - 以下の場合にさらなる質問を停止する:
       - すべての重要な曖昧さが早期に解決された (残りのキュー項目が不要になった)、または
       - ユーザーが完了を合図した ("done", "good", "no more")、または
       - 5つの質問を行った。
    - 将来のキューされた質問を事前に明かさないこと。
    - 開始時に有効な質問が存在しない場合、直ちに重要な曖昧さがないことを報告する。

5. 各**承認された回答**後の統合 (増分更新アプローチ):
    - specのインメモリ表現 (開始時に一度ロード) と生ファイルコンテンツを維持する。
    - このセッションでの最初の統合回答について:
       - `## Clarifications` (明確化) セクションが存在することを確認する (欠落している場合は、specテンプレートに従って最上位のコンテキスト/概要セクションの直後に作成)。
       - その下に、今日の `### S質問: <質問> → 回答-MM-DD` サブ見出しを (存在しない場合) 作成する。
    - 受理直後に箇条書き行を追加: `- Q: <質問> → A: <最終回答>`。
    - その後、直ちに明確化を最も適切なセクションに適用する:
       - 機能的曖昧さ → 機能要件の箇条書きを更新または追加。
       - ユーザーインタラクション/アクターの区別 → ユーザーストーリーまたはアクターサブセクション (存在する場合) を、明確化された役割、制約、またはシナリオで更新。
       - データ形状/エンティティ → データモデルを更新 (フィールド、型、関係を追加) し、順序を維持; 追加された制約を簡潔にメモする。
       - 非機能制約 → 非機能/品質属性セクションの測定可能な基準を追加/修正 (曖昧な形容詞をメトリクスまたは明示的なターゲットに変換)。
       - エッジケース/ネガティブフロー → エッジケース/エラー処理の下に新しい箇条書きを追加 (テンプレートにプレースホルダーがある場合はそのようなサブセクションを作成)。
       - 用語の競合 → spec全体で用語を正規化; 必要な場合のみ `(以前の呼称: "X")` を一度追加して元の用語を保持。
    - 明確化が以前の曖昧な記述を無効にする場合、複製するのではなくその記述を置き換える; 古くなった矛盾するテキストを残さない。
    - コンテキスト損失のリスクを最小限に抑えるため、各統合**後**にspecファイルを保存する (アトミック上書き)。
    - フォーマットを維持: 無関係なセクションを並べ替えない; 見出し階層を維持する。
    - 各挿入された明確化を最小限かつテスト可能に保つ (物語的な脱線を避ける)。

6. 検証 (各書き込み後および最終パスで行う):
    - 明確化セッションには、承認された回答ごとに正確に1つの箇条書きが含まれる (重複なし)。
    - 合計質問数 (承認済み) ≤ 5。
    - 更新されたセクションには、新しい回答が解決するはずだった長引く曖昧なプレースホルダーが含まれていない。
    - 以前の矛盾する記述が残っていない (削除された今や無効な代替選択肢をスキャン)。
    - Markdown構造が有効; 許可される新しい見出しのみ: `## Clarifications`, `### Session YYYY-MM-DD`。
    - 用語の一貫性: すべての更新されたセクションで同じ正規用語が使用されている。

7. 更新された spec を `FEATURE_SPEC` に書き戻す。

8. 完了報告 (質問ループ終了後または早期終了後):
   - 質問および回答された数。
   - 更新された spec へのパス。
   - 更新されたセクション (名前をリスト)。
   - カバレッジサマリーテーブル。各分類カテゴリのステータス: 解決済み (Resolved - 以前は部分的/欠落)、保留 (Deferred - クォータ超過/計画に最適)、明確 (Clear - 既に十分)、未解決 (Outstanding - 部分的/欠落だが低影響)。
   - 未解決 または 保留 が残っている場合、`/speckit.plan` に進むか、計画後に再度 `/speckit.clarify` を実行するか推奨する。
   - 提案される次のコマンド。

動作ルール:

- 意味のある曖昧さが見つからない場合 (またはすべての潜在的な質問が低影響の場合)、「正式な明確化に値する重要な曖昧さは検出されませんでした。」と応答し、進めることを提案する。
- specファイルが欠落している場合、ユーザーにまず `/speckit.specify` を実行するよう指示する (ここで新しいspecを作成しない)。
- 合計質問数5を超えないこと (単一の質問に対する明確化の再試行は新しい質問としてカウントしない)。
- 機能の明確さをブロックしない限り、推測的な技術スタックの質問を避ける。
- ユーザーの早期終了シグナル ("stop", "done", "proceed") を尊重する。
- 完全なカバレッジのために質問が行われなかった場合、コンパクトなカバレッジサマリー (すべて Clear) を出力してから進めることを提案する。
- クォータに達し、未解決の高影響カテゴリが残っている場合、理由とともに Deferred の下でそれらを明示的にフラグ付けする。

優先順位付けのコンテキスト: {ARGS}
