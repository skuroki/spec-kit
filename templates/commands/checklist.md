---
description: ユーザー要件に基づいて、現在の機能のためのカスタムチェックリストを生成します。
scripts:
  sh: scripts/bash/check-prerequisites.sh --json
  ps: scripts/powershell/check-prerequisites.ps1 -Json
---

## チェックリストの目的: "英語のためのユニットテスト"

**重要な概念**: チェックリストは **要件記述のためのユニットテスト** です - これらは特定のドメインにおける要件の品質、明確さ、完全性を検証します。

**検証/テスト用ではありません**:

- ❌ "ボタンが正しくクリックできるか確認する" ではありません
- ❌ "エラー処理が機能することをテストする" ではありません
- ❌ "APIが200を返すことを確認する" ではありません
- ❌ コード/実装が仕様と一致しているかチェックするものではありません

**要件品質の検証用です**:

- ✅ "すべてのカードタイプに対して視覚的階層の要件が定義されているか？" (完全性)
- ✅ "'目立つ表示'は具体的なサイズ/配置で定量化されているか？" (明確さ)
- ✅ "ホバー状態の要件はすべてのインタラクティブ要素で一貫しているか？" (一貫性)
- ✅ "キーボード操作のアクセシビリティ要件は定義されているか？" (カバレッジ)
- ✅ "ロゴ画像の読み込みに失敗したときの動作を仕様が定義しているか？" (エッジケース)

**比喩**: 仕様書が英語で書かれたコードだとすれば、チェックリストはそのユニットテストスイートです。テストしているのは、要件が適切に記述され、完全で、曖昧さがなく、実装の準備ができているかどうかであり、実装が機能するかどうかではありません。

## ユーザー入力

```text
$ARGUMENTS
```

先に進む前にユーザー入力を**必ず**考慮してください（入力が空でない場合）。

## 実行ステップ

1. **セットアップ**: リポジトリルートから `{SCRIPT}` を実行し、FEATURE_DIR と AVAILABLE_DOCS リストのJSONをパースする。
   - すべてのファイルパスは絶対パスであること。
   - 引数内のシングルクォート（例: "I'm Groot"）については、エスケープ構文を使用すること: 例 'I'\''m Groot'（または可能ならダブルクォート: "I'm Groot"）。

2. **意図の明確化 (動的)**: 最大3つの初期コンテキスト明確化質問を導き出す (事前に用意されたカタログではない)。これらは以下を満たさなければなりません(MUST):
   - ユーザーの言い回し + spec/plan/tasks から抽出されたシグナルから生成されること
   - チェックリストの内容を実質的に変更する情報についてのみ質問すること
   - `$ARGUMENTS` ですでに明確な場合は個別にスキップすること
   - 広さよりも正確さを優先すること

   生成アルゴリズム:
   1. シグナル抽出: 機能ドメインキーワード (例: auth, latency, UX, API)、リスク指標 ("critical", "must", "compliance")、ステークホルダーのヒント ("QA", "review", "security team")、および明示的な成果物 ("a11y", "rollback", "contracts")。
   2. シグナルを候補フォーカスエリア (最大4つ) にクラスタリングし、関連性順にランク付けする。
   3. 明示的でない場合、推定されるオーディエンスとタイミング (作成者, レビュアー, QA, リリース) を特定する。
   4. 欠落している次元を検出する: スコープの広さ、深さ/厳密さ、リスクの強調、除外境界、測定可能な受入基準。
   5. 以下のアーキタイプから質問を作成する:
      - スコープの具体化 (例: "これはXやYとの統合タッチポイントを含めるべきか、それともローカルモジュールの正しさに限定すべきか？")
      - リスクの優先順位付け (例: "これらの潜在的なリスク領域のうち、どれが必須のゲーティングチェックを受けるべきか？")
      - 深さの調整 (例: "これは軽量なコミット前サニティリストか、それとも正式なリリースゲートか？")
      - オーディエンスフレーミング (例: "これは作成者のみが使用するのか、それともPRレビュー中にピアが使用するのか？")
      - 境界の除外 (例: "今回はパフォーマンスチューニング項目を明示的に除外すべきか？")
      - シナリオクラスのギャップ (例: "リカバリーフローが検出されませんでした — ロールバック/部分的な失敗パスはスコープ内か？")

   質問のフォーマットルール:
   - オプションを提示する場合、以下の列を持つコンパクトなテーブルを生成する: Option | Candidate | Why It Matters
   - 最大 A–E オプションまで; 自由形式の回答の方が明確な場合はテーブルを省略する
   - ユーザーがすでに言ったことを繰り返させないこと
   - 推測的なカテゴリを避ける (幻覚を見ない)。不確かな場合は明示的に尋ねる: "Confirm whether X belongs in scope." (Xがスコープに含まれるか確認してください)

   対話が不可能な場合のデフォルト:
   - 深さ: 標準
   - オーディエンス: コード関連ならレビュアー (PR); それ以外なら作成者
   - フォーカス: 関連性上位2つのクラスター

   質問を出力する (Q1/Q2/Q3とラベル付け)。回答後: もし2つ以上のシナリオクラス (代替 / 例外 / リカバリー / 非機能ドメイン) が不明瞭なままなら、最大2つのターゲットを絞ったフォローアップ質問 (Q4/Q5) をそれぞれ1行の正当化理由 (例: "Unresolved recovery path risk") とともに行ってもよい(MAY)。合計5問を超えないこと。ユーザーがこれ以上を明示的に断った場合はエスカレーションをスキップする。

3. **ユーザー要求の理解**: `$ARGUMENTS` + 明確化への回答を結合する:
   - チェックリストのテーマを導出 (例: security, review, deploy, ux)
   - ユーザーが言及した明示的な必須項目を統合
   - フォーカス選択をカゴリスキャフォールディングにマッピング
   - spec/plan/tasks から欠落しているコンテキストを推論 (幻覚を見ないこと)

4. **機能コンテキストの読み込み**: FEATURE_DIR から読み込む:
   - spec.md: 機能要件とスコープ
   - plan.md (存在する場合): 技術的詳細、依存関係
   - tasks.md (存在する場合): 実装タスク

   **コンテキスト読み込み戦略**:
   - アクティブなフォーカスエリアに関連する必要な部分のみをロードする (ファイル全体のダンプを避ける)
   - 長いセクションを簡潔なシナリオ/要件箇条書きに要約することを優先する
   - 段階的開示を使用: ギャップが検出された場合のみフォローオン検索を追加する
   - ソースドキュメントが大きい場合、生テキストを埋め込むのではなく中間要約項目を生成する

5. **チェックリスト生成** - "要件のためのユニットテスト" を作成:
   - `FEATURE_DIR/checklists/` ディレクトリが存在しない場合は作成
   - ユニークなチェックリストファイル名を生成:
     - ドメインに基づいた短く記述的な名前を使用 (例: `ux.md`, `api.md`, `security.md`)
     - 形式: `[domain].md`
     - ファイルが存在する場合は既存ファイルに追記
   - CHK001 から始まる連番を振る
   - 各 `/speckit.checklist` 実行は新しいファイルを作成する (既存のチェックリストを上書きしない)

   **コア原則 - 実装ではなく要件をテストする**:
   すべてのチェックリスト項目は、**要件そのもの**を以下について評価しなければなりません(MUST):
   - **完全性**: 必要なすべての要件が存在するか？
   - **明確さ**: 要件は曖昧でなく具体的か？
   - **一貫性**: 要件は互いに整合しているか？
   - **測定可能性**: 要件は客観的に検証可能か？
   - **カバレッジ**: すべてのシナリオ/エッジケースが対処されているか？

   **カテゴリ構造** - 要件品質の次元ごとに項目をグループ化:
   - **要件の完全性** (必要なすべての要件が文書化されているか？)
   - **要件の明確さ** (要件は具体的で曖昧でないか？)
   - **要件の一貫性** (要件は矛盾なく整合しているか？)
   - **受入基準の品質** (成功基準は測定可能か？)
   - **シナリオカバレッジ** (すべてのフロー/ケースが対処されているか？)
   - **エッジケースカバレッジ** (境界条件は定義されているか？)
   - **非機能要件** (パフォーマンス、セキュリティ、アクセシビリティなどは指定されているか？)
   - **依存関係と仮定** (それらは文書化され検証されているか？)
   - **曖昧さと矛盾** (何が明確化を必要としているか？)

   **チェックリスト項目の書き方 - "英語のためのユニットテスト"**:

   ❌ **間違い** (実装のテスト):
   - "ランディングページに3つのエピソードカードが表示されることを検証する"
   - "デスクトップでホバー状態が機能することをテストする"
   - "ロゴのクリックでホームに遷移することを確認する"

   ✅ **正解** (要件品質のテスト):
   - "注目のエピソードの正確な数とレイアウトは指定されているか？" [完全性]
   - "'目立つ表示'は具体的なサイズ/配置で定量化されているか？" [明確さ]
   - "ホバー状態の要件はすべてのインタラクティブ要素で一貫しているか？" [一貫性]
   - "キーボードナビゲーション要件はすべてのインタラクティブUIに対して定義されているか？" [カバレッジ]
   - "ロゴ画像の読み込みに失敗したときのフォールバック動作は指定されているか？" [エッジケース]
   - "非同期エピソードデータに対するローディング状態は定義されているか？" [完全性]
   - "仕様は競合するUI要素の視覚的階層を定義しているか？" [明確さ]

   **項目構造**:
   各項目はこのパターンに従うべきです:
   - 要件品質について尋ねる質問形式
   - spec/plan に書かれていること (または書かれていないこと) に焦点を当てる
   - 括弧内に品質次元を含める [Completeness/Clarity/Consistency/etc.]
   - 既存の要件をチェックする場合は仕様セクション `[Spec §X.Y]` を参照する
   - 要件の欠落をチェックする場合は `[Gap]` マーカーを使用する

   **品質次元ごとの例**:

   完全性 (Completeness):
   - "すべてのAPI失敗モードに対してエラー処理要件が定義されているか？ [Gap]"
   - "すべてのインタラクティブ要素に対してアクセシビリティ要件が指定されているか？ [Completeness]"
   - "レスポンシブレイアウトのモバイルブレークポイント要件は定義されているか？ [Gap]"

   明確さ (Clarity):
   - "'高速読み込み'は具体的なタイミング閾値で定量化されているか？ [Clarity, Spec §NFR-2]"
   - "'関連エピソード'の選択基準は明示的に定義されているか？ [Clarity, Spec §FR-5]"
   - "'目立つ'は測定可能な視覚特性で定義されているか？ [Ambiguity, Spec §FR-4]"

   一貫性 (Consistency):
   - "ナビゲーション要件はすべてのページで整合しているか？ [Consistency, Spec §FR-10]"
   - "カードコンポーネントの要件はランディングページと詳細ページ間で一貫しているか？ [Consistency]"

   カバレッジ (Coverage):
   - "ゼロ状態シナリオ (エピソードなし) の要件は定義されているか？ [Coverage, Edge Case]"
   - "同時ユーザーインタラクションシナリオは対処されているか？ [Coverage, Gap]"
   - "部分的なデータ読み込み失敗に対する要件は指定されているか？ [Coverage, Exception Flow]"

   測定可能性 (Measurability):
   - "視覚的階層の要件は測定可能/テスト可能か？ [Acceptance Criteria, Spec §FR-1]"
   - "'バランスの取れた視覚的重み'は客観的に検証可能か？ [Measurability, Spec §FR-2]"

   **シナリオ分類とカバレッジ** (要件品質フォーカス):
   - 以下の要件が存在するかチェック: Primary, Alternate, Exception/Error, Recovery, Non-Functional scenarios
   - 各シナリオクラスについて尋ねる: "[シナリオタイプ]の要件は完全、明確、かつ一貫しているか？"
   - シナリオクラスが欠落している場合: "[シナリオタイプ]の要件は意図的に除外されているか、それとも欠落しているか？ [Gap]"
   - 状態変化が発生する場合の回復力/ロールバックを含む: "移行失敗時のロールバック要件は定義されているか？ [Gap]"

   **トレーサビリティ要件**:
   - 最小限: 80%以上の項目が少なくとも1つのトレーサビリティ参照を含まなければならない(MUST)
   - 各項目は以下を参照すべき: specセクション `[Spec §X.Y]`, またはマーカー使用: `[Gap]`, `[Ambiguity]`, `[Conflict]`, `[Assumption]`
   - IDシステムが存在しない場合: "要件と受入基準のIDスキームは確立されているか？ [Traceability]"

   **問題の表面化と解決** (要件品質の問題):
   要件そのものについて質問する:
   - 曖昧さ: "'高速'という用語は具体的な指標で定量化されているか？ [Ambiguity, Spec §NFR-1]"
   - 矛盾: "ナビゲーション要件は §FR-10 と §FR-10a の間で矛盾していないか？ [Conflict]"
   - 仮定: "'常に利用可能なポッドキャストAPI'という仮定は検証されているか？ [Assumption]"
   - 依存関係: "外部ポッドキャストAPI要件は文書化されているか？ [Dependency, Gap]"
   - 定義の欠落: "'視覚的階層'は測定可能な基準で定義されているか？ [Gap]"

   **コンテンツの統合**:
   - ソフトキャップ: 生の候補項目が40を超える場合、リスク/影響度で優先順位付けする
   - 同じ要件側面をチェックするほぼ重複した項目をマージする
   - 低影響のエッジケースが5つを超える場合、1つの項目を作成する: "エッジケースX, Y, Zは要件で対処されているか？ [Coverage]"

   **🚫 絶対に禁止** - これらは要件テストではなく実装テストにしてしまいます:
   - ❌ "Verify", "Test", "Confirm", "Check" + 実装の振る舞いで始まる項目
   - ❌ コード実行、ユーザーアクション、システム動作への言及
   - ❌ "正しく表示される", "適切に動作する", "期待通りに機能する"
   - ❌ "Click", "navigate", "render", "load", "execute"
   - ❌ テストケース、テスト計画、QA手順
   - ❌ 実装の詳細 (フレームワーク, API, アルゴリズム)

   **✅ 必須パターン** - これらは要件品質をテストします:
   - ✅ "[シナリオ]に対して[要件タイプ]は定義/指定/文書化されているか？"
   - ✅ "[曖昧な用語]は具体的な基準で定量化/明確化されているか？"
   - ✅ "要件は[セクションA]と[セクションB]の間で一貫しているか？"
   - ✅ "[要件]は客観的に測定/検証可能か？"
   - ✅ "[エッジケース/シナリオ]は要件で対処されているか？"
   - ✅ "仕様は[欠落している側面]を定義しているか？"

6. **構造リファレンス**: タイトル、メタセクション、カテゴリ見出し、IDフォーマットについては、`templates/checklist-template.md` の標準テンプレートに従ってチェックリストを生成する。テンプレートが利用できない場合は次を使用: H1タイトル、目的/作成日メタ行、`##` カテゴリセクション (+ `- [ ] CHK### <要件項目>` 行、IDはCHK001からグローバルに増加)。

7. **レポート**: 作成されたチェックリストへのフルパス、項目数を出力し、各実行が新しいファイルを作成することをユーザーに思い出させる。以下を要約する:
   - 選択されたフォーカスエリア
   - 深さレベル (Depth level)
   - アクター/タイミング
   - 組み込まれた明示的なユーザー指定の必須項目

**重要**: 各 `/speckit.checklist` コマンド呼び出しは、ファイルがすでに存在しない限り、短く記述的な名前を使用してチェックリストファイルを作成します。これにより以下が可能になります:

- 異なるタイプの複数のチェックリスト (例: `ux.md`, `test.md`, `security.md`)
- チェックリストの目的を示すシンプルで覚えやすいファイル名
- `checklists/` フォルダ内での容易な識別とナビゲーション

混乱を避けるために、記述的なタイプを使用し、完了したら不要なチェックリストをクリーンアップしてください。

## チェックリストタイプの例とサンプル項目

**UX要件品質:** `ux.md`

サンプル項目 (実装ではなく要件をテストする):

- "視覚的階層の要件は測定可能な基準で定義されているか？ [Clarity, Spec §FR-1]"
- "UI要素の数と配置は明示的に指定されているか？ [Completeness, Spec §FR-1]"
- "インタラクション状態の要件 (hover, focus, active) は一貫して定義されているか？ [Consistency]"
- "アクセシビリティ要件はすべてのインタラクティブ要素に対して指定されているか？ [Coverage, Gap]"
- "画像読み込み失敗時のフォールバック動作は定義されているか？ [Edge Case, Gap]"
- "'目立つ表示'は客観的に測定可能か？ [Measurability, Spec §FR-4]"

**API要件品質:** `api.md`

サンプル項目:

- "すべての失敗シナリオに対してエラーレスポンス形式は指定されているか？ [Completeness]"
- "レート制限要件は具体的な閾値で定量化されているか？ [Clarity]"
- "認証要件はすべてのエンドポイントで一貫しているか？ [Consistency]"
- "外部依存関係に対するリトライ/タイムアウト要件は定義されているか？ [Coverage, Gap]"
- "バージョニング戦略は要件に文書化されているか？ [Gap]"

**パフォーマンス要件品質:** `performance.md`

サンプル項目:

- "パフォーマンス要件は具体的な指標で定量化されているか？ [Clarity]"
- "すべての重要なユーザージャーニーに対してパフォーマンス目標は定義されているか？ [Coverage]"
- "異なる負荷条件下でのパフォーマンス要件は指定されているか？ [Completeness]"
- "パフォーマンス要件は客観的に測定可能か？ [Measurability]"
- "高負荷シナリオに対する縮退要件は定義されているか？ [Edge Case, Gap]"

**セキュリティ要件品質:** `security.md`

サンプル項目:

- "すべての保護されたリソースに対して認証要件は指定されているか？ [Coverage]"
- "機密情報に対するデータ保護要件は定義されているか？ [Completeness]"
- "脅威モデルは文書化され、要件はそれに整合しているか？ [Traceability]"
- "セキュリティ要件はコンプライアンス義務と一貫しているか？ [Consistency]"
- "セキュリティ失敗/侵害対応要件は定義されているか？ [Gap, Exception Flow]"

## 反面教師: やってはいけないこと (Anti-Examples)

**❌ 間違い - これらは要件ではなく実装をテストしています:**

```markdown
- [ ] CHK001 - ランディングページに3つのエピソードカードが表示されることを検証する [Spec §FR-001]
- [ ] CHK002 - デスクトップでホバー状態が正しく機能することをテストする [Spec §FR-003]
- [ ] CHK003 - ロゴのクリックでホームページに遷移することを確認する [Spec §FR-010]
- [ ] CHK004 - 関連エピソードセクションに3-5項目が表示されることをチェックする [Spec §FR-005]
```

**✅ 正解 - これらは要件品質をテストしています:**

```markdown
- [ ] CHK001 - 注目のエピソードの数とレイアウトは明示的に指定されているか？ [Completeness, Spec §FR-001]
- [ ] CHK002 - ホバー状態の要件はすべてのインタラクティブ要素で一貫して定義されているか？ [Consistency, Spec §FR-003]
- [ ] CHK003 - ナビゲーション要件はすべてのクリック可能なブランド要素に対して明確か？ [Clarity, Spec §FR-010]
- [ ] CHK004 - 関連エピソードの選択基準は文書化されているか？ [Gap, Spec §FR-005]
- [ ] CHK005 - 非同期エピソードデータに対するローディング状態要件は定義されているか？ [Gap]
- [ ] CHK006 - "視覚的階層"要件は客観的に測定可能か？ [Measurability, Spec §FR-001]
```

**主な違い:**

- 間違い: システムが正しく動作するかをテスト
- 正解: 要件が正しく書かれているかをテスト
- 間違い: 振る舞いの検証 (Verification)
- 正解: 要件品質の妥当性確認 (Validation)
- 間違い: "それはXをしますか？"
- 正解: "Xは明確に指定されていますか？"
